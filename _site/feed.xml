<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>备忘录</title>
    <description>愚者千虑，或有一得。
</description>
    <link>http://shenmimoon.github.io/</link>
    <atom:link href="http://shenmimoon.github.io/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Sat, 21 May 2016 21:11:49 +0800</pubDate>
    <lastBuildDate>Sat, 21 May 2016 21:11:49 +0800</lastBuildDate>
    <generator>Jekyll v3.2.0.pre.beta1</generator>
    
      <item>
        <title>Spring注解式cache机制</title>
        <description>&lt;h1 id=&quot;springcache&quot;&gt;Spring注解式cache机制&lt;/h1&gt;

&lt;h2 id=&quot;section&quot;&gt;缓存概述&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/resources/images/overview.png&quot; alt=&quot;缓存&quot; title=&quot;缓存&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;spring-cache&quot;&gt;Spring cache概述&lt;/h2&gt;
&lt;p&gt;Spring的cache是对一种缓存使用场景的抽象:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;有限的&lt;/strong&gt; KV结构的数据,在更新/删除时刷新,未命中需要加载的 &lt;strong&gt;本地缓存&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;通过注解配置cache的分类,SPEL式的key表达式和缓存条件表达式,通过AOP的方式在调用时执行缓存加载/刷新/清除逻辑。&lt;br /&gt;
由于结构限制,无法简单实现过期加载。&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;缓存管理器实现&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;接口&lt;code class=&quot;highlighter-rouge&quot;&gt;CacheManager&lt;/code&gt;及抽象类&lt;code class=&quot;highlighter-rouge&quot;&gt;AbstractCacheManager&lt;/code&gt;:&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;CacheManager&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;

    &lt;span class=&quot;cm&quot;&gt;/**
     * Return the cache associated with the given name.
     * @param name cache identifier (must not be {@code null})
     * @return associated cache, or {@code null} if none is found
     */&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Cache&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;getCache&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;

    &lt;span class=&quot;cm&quot;&gt;/**
     * Return a collection of the caches known by this cache manager.
     * @return names of caches known by the cache manager.
     */&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Collection&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;getCacheNames&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;

&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;    
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;作为全局的缓存管理器, &lt;code class=&quot;highlighter-rouge&quot;&gt;CacheManager&lt;/code&gt; 的作用是管理 &lt;code class=&quot;highlighter-rouge&quot;&gt;cacheNames&lt;/code&gt;,既每个缓存使用时机标识,默认实现是在bean初始化结束后,初始化&lt;code class=&quot;highlighter-rouge&quot;&gt;cacheMap&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;abstract&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;AbstractCacheManager&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CacheManager&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;InitializingBean&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ConcurrentMap&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Cache&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cacheMap&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ConcurrentHashMap&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Cache&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;();&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Set&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cacheNames&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;LinkedHashSet&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;();&lt;/span&gt;


    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;afterPropertiesSet&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;Collection&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;?&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Cache&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;caches&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;loadCaches&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;Assert&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;notEmpty&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;caches&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;loadCaches must not return an empty Collection&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;cacheMap&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;clear&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;

        &lt;span class=&quot;c1&quot;&gt;// preserve the initial order of the cache names&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Cache&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cache&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;caches&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;cacheMap&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;put&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cache&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getName&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cache&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;cacheNames&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;add&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cache&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getName&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;());&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;addCache&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Cache&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cache&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;cacheMap&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;put&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cache&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getName&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cache&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;cacheNames&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;add&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cache&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getName&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;());&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Cache&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;getCache&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;cacheMap&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Collection&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;getCacheNames&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Collections&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;unmodifiableSet&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;cacheNames&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;


    &lt;span class=&quot;cm&quot;&gt;/**
     * Load the caches for this cache manager. Occurs at startup.
     * The returned collection must not be null.
     */&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;abstract&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Collection&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;?&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Cache&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;loadCaches&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;

&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;  
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;section-2&quot;&gt;缓存结构&lt;/h2&gt;

&lt;p&gt;接口&lt;code class=&quot;highlighter-rouge&quot;&gt;Cache&lt;/code&gt;定义了缓存结构需要实现的功能:  &lt;br /&gt;
```java
public interface Cache {&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/**
 * Return the cache name.
 */
String getName();

/**
 * Return the the underlying native cache provider.
 */
Object getNativeCache();

/**
 * Return the value to which this cache maps the specified key. Returns
 * &amp;lt;code&amp;gt;null&amp;lt;/code&amp;gt; if the cache contains no mapping for this key.
 * @param key key whose associated value is to be returned.
 * @return the value to which this cache maps the specified key,
 * or &amp;lt;code&amp;gt;null&amp;lt;/code&amp;gt; if the cache contains no mapping for this key
 */
ValueWrapper get(Object key);

/**
 * Associate the specified value with the specified key in this cache.
 * &amp;lt;p&amp;gt;If the cache previously contained a mapping for this key, the old
 * value is replaced by the specified value.
 * @param key the key with which the specified value is to be associated
 * @param value the value to be associated with the specified key
 */
void put(Object key, Object value);

/**
 * Evict the mapping for this key from this cache if it is present.
 * @param key the key whose mapping is to be removed from the cache
 */
void evict(Object key);

/**
 * Remove all mappings from the cache.
 */
void clear();


/**
 * A (wrapper) object representing a cache value.
 */
interface ValueWrapper {

    /**
     * Return the actual value in the cache.
     */
    Object get();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;}
```
需要实现缓存记录的put/get/evict/clear等方法。&lt;/p&gt;

&lt;h2 id=&quot;aop&quot;&gt;AOP加载配置&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;/resources/images/diagram.png&quot; alt=&quot;Advisor&quot; title=&quot;Adviser&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-3&quot;&gt;缓存调用流程&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;/resources/images/缓存调用流程.png&quot; alt=&quot;缓存调用流程&quot; title=&quot;缓存调用流程&quot; /&gt;&lt;/p&gt;
</description>
        <pubDate>Sat, 21 May 2016 00:00:00 +0800</pubDate>
        <link>http://shenmimoon.github.io/2016/05/21/Spring%E6%B3%A8%E8%A7%A3%E5%BC%8F-cache-%E6%9C%BA%E5%88%B6.html</link>
        <guid isPermaLink="true">http://shenmimoon.github.io/2016/05/21/Spring%E6%B3%A8%E8%A7%A3%E5%BC%8F-cache-%E6%9C%BA%E5%88%B6.html</guid>
        
        <category>Spring</category>
        
        
      </item>
    
      <item>
        <title>Find&amp;Grep</title>
        <description>&lt;h1 id=&quot;findgrep&quot;&gt;Find&amp;amp;Grep&lt;/h1&gt;

&lt;p&gt;在linux下面工作，有些命令能够大大提高效率。本文就向大家介绍find、grep命令，他哥俩可以算是必会的linux命令，我几乎每天都要用到他们。本文结构如下：&lt;/p&gt;

&lt;p&gt;[TOC]&lt;/p&gt;

&lt;h2 id=&quot;find&quot;&gt;1、find命令&lt;/h2&gt;

&lt;p&gt;find命令是一个无处不在命令，是linux中最有用的命令之一。find命令用于：在一个目录（及子目录）中搜索文件，你可以指定一些匹配条件，如按文件名、文件类型、用户甚至是时间戳查找文件。下面就通过实例来体验下find命令的强大。&lt;/p&gt;

&lt;h3 id=&quot;find-1&quot;&gt;1.1、find命令的一般形式&lt;/h3&gt;

&lt;p&gt;man文档中给出的find命令的一般形式为：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;find [-H] [-L] [-P] [-D debugopts] [-Olevel] [path...] [expression]
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;其实&lt;code class=&quot;highlighter-rouge&quot;&gt;[-H]&lt;/code&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;[-L]&lt;/code&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;[-P]&lt;/code&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;[-D debugopts]&lt;/code&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;[-Olevel]&lt;/code&gt;这几个选项并不常用（至少在我的日常工作中，没有用到过），上面的find命令的常用形式可以简化为：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;find [path...] [expression]
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;path&lt;/code&gt;：find命令所查找的目录路径。例如用.来表示当前目录，用/来表示系统根目录
&lt;code class=&quot;highlighter-rouge&quot;&gt;expression&lt;/code&gt;：expression可以分为——“-options [-print -exec -ok …]”
&lt;code class=&quot;highlighter-rouge&quot;&gt;-options&lt;/code&gt;，指定find命令的常用选项，下节详细介绍
&lt;code class=&quot;highlighter-rouge&quot;&gt;-print&lt;/code&gt;，find命令将匹配的文件输出到标准输出
&lt;code class=&quot;highlighter-rouge&quot;&gt;-exec&lt;/code&gt;，find命令对匹配的文件执行该参数所给出的shell命令。相应命令的形式为’command’ {  } \;，注意{   }和\；之间的空格&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;find ./ -size 0 -exec rm {} \;  删除文件大小为零的文件 （还可以以这样做：``rm -i `find ./ -size 0` `` 或 `find ./ -size 0 | xargs rm -f &amp;amp;`）  为了用`ls -l`命令列出所匹配到的文件，可以把`ls -l`命令放在`find`命令的`-exec`选项中：

find . -type f -exec ls -l {  } \;  在/logs目录中查找更改时间在5日以前的文件并删除它们：

find /logs -type f -mtime +5 -exec rm {  } \; `-ok`，和`-exec`的作用相同，只不过以一种更为安全的模式来执行该参数所给出的shell命令，在执行每一个命令之前，都会给出提示，让用户来确定是否执行。 

find . -name &quot;*.conf&quot;  -mtime +5 -ok rm {  } \;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;在当前目录中查找所有文件名以.LOG结尾、更改时间在5日以上的文件，并删除它们，只不过在删除之前先给出提示
也有人这样总结&lt;code class=&quot;highlighter-rouge&quot;&gt;find&lt;/code&gt;命令的结构：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;find start_directory test 
     options 
     criteria_to_match 
     action_to_perform_on_results
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;find-2&quot;&gt;1.2、find命令的常用选项及实例&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-name&lt;/code&gt; 按照文件名查找文件。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;find /dir -name filename&lt;/code&gt;  在/dir目录及其子目录下面查找名字为filename的文件&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;find . -name &quot;*.c&quot;&lt;/code&gt; 在当前目录及其子目录（用“.”表示）中查找任何扩展名为“c”的文件&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-perm&lt;/code&gt; 按照文件权限来查找文件。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;find . -perm 755 –print&lt;/code&gt; 在当前目录下查找文件权限位为755的文件，即文件属主可以读、写、执行，其他用户可以读、执行的文件&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-prune&lt;/code&gt; 使用这一选项可以使find命令不在当前指定的目录中查找，如果同时使用-depth选项，那么-prune将被find命令忽略。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;find /apps -path &quot;/apps/bin&quot; -prune -o –print&lt;/code&gt; 在/apps目录下查找文件，但不希望在/apps/bin目录下查找&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;find /usr/sam -path &quot;/usr/sam/dir1&quot; -prune -o –print&lt;/code&gt; 在/usr/sam目录下查找不在dir1子目录之内的所有文件&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-user&lt;/code&gt; 按照文件属主来查找文件。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;find ~ -user sam –print&lt;/code&gt; 在$HOME目录中查找文件属主为sam的文件&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-group&lt;/code&gt; 按照文件所属的组来查找文件。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;find /apps -group gem –print&lt;/code&gt; 在/apps目录下查找属于gem用户组的文件&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-mtime -n +n&lt;/code&gt; 按照文件的更改时间来查找文件， &lt;code class=&quot;highlighter-rouge&quot;&gt;-n&lt;/code&gt; 表示文件更改时间距现在n天以内，&lt;code class=&quot;highlighter-rouge&quot;&gt;+n&lt;/code&gt;表示文件更改时间距现在n天以前。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;find / -mtime -5 –print&lt;/code&gt; 在系统根目录下查找更改时间在5日以内的文件&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;find /var/adm -mtime +3 –print&lt;/code&gt; 在/var/adm目录下查找更改时间在3日以前的文件&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-nogroup&lt;/code&gt; 查找无有效所属组的文件，即该文件所属的组在/etc/groups中不存在。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;find / –nogroup -print&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-nouser &lt;/code&gt; 查找无有效属主的文件，即该文件的属主在/etc/passwd中不存在。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;find /home -nouser –print&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-newer file1 ! file2 &lt;/code&gt;查找更改时间比文件file1新但比文件file2旧的文件。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-type&lt;/code&gt; 查找某一类型的文件，诸如:&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;b - 块设备文件。&lt;/li&gt;
      &lt;li&gt;d - 目录。&lt;/li&gt;
      &lt;li&gt;c - 字符设备文件。&lt;/li&gt;
      &lt;li&gt;p - 管道文件。&lt;/li&gt;
      &lt;li&gt;l - 符号链接文件。&lt;/li&gt;
      &lt;li&gt;f - 普通文件。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;find /etc -type d –print 在/etc目录下查找所有的目录 
find . ! -type d –print 在当前目录下查找除目录以外的所有类型的文件 
find /etc -type l –print 在/etc目录下查找所有的符号链接文件
-size n：[c] 查找文件长度为n块的文件，带有c时表示文件长度以字节计。 
find . -size +1000000c –print 在当前目录下查找文件长度大于1 M字节的文件 
find /home/apache -size 100c –print 在/home/apache目录下查找文件长度恰好为100字节的文件 
find . -size +10 –print 在当前目录下查找长度超过10块的文件（一块等于512字节）
-depth：在查找文件时，首先查找当前目录中的文件，然后再在其子目录中查找。 
find / -name “CON.FILE” -depth –print 它将首先匹配所有的文件然后再进入子目录中查找 
-mount：在查找文件时不跨越文件系统mount点。&lt;br /&gt;
find . -name “*.XC” -mount –print 从当前目录开始查找位于本文件系统中文件名以XC结尾的文件（不进入其他文件系统）
-follow：如果find命令遇到符号链接文件，就跟踪至链接所指向的文件。
1.3、find与xargs
在使用find命令的-exec选项处理匹配到的文件时， find命令将所有匹配到的文件一起传递给exec执行。但有些系统对能够传递给exec的命令长度有限制，这样在find命令运行几分钟之后，就会出现溢出错误。错误信息通常是“参数列太长”或“参数列溢出”。这就是xargs命令的用处所在，特别是与find命令一起使用。&lt;/p&gt;

&lt;p&gt;find命令把匹配到的文件传递给xargs命令，而xargs命令每次只获取一部分文件而不是全部，不像-exec选项那样。这样它可以先处理最先获取的一部分文件，然后是下一批，并如此继续下去。&lt;/p&gt;

&lt;p&gt;在有些系统中，使用-exec选项会为处理每一个匹配到的文件而发起一个相应的进程，并非将匹配到的文件全部作为参数一次执行；这样在有些情况下就会出现进程过多，系统性能下降的问题，因而效率不高；&lt;/p&gt;

&lt;p&gt;而使用xargs命令则只有一个进程。另外，在使用xargs命令时，究竟是一次获取所有的参数，还是分批取得参数，以及每一次获取参数的数目都会根据该命令的选项及系统内核中相应的可调参数来确定。&lt;/p&gt;

&lt;p&gt;来看看xargs命令是如何同find命令一起使用的，并给出一些例子。&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;find . -type f -print&lt;/td&gt;
      &lt;td&gt;xargs file 查找系统中的每一个普通文件，然后使用xargs命令来测试它们分别属于哪类文件&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;find / -name “core” -print&lt;/td&gt;
      &lt;td&gt;xargs echo “” &amp;gt;/tmp/core.log 在整个系统中查找内存信息转储文件(core dump) ，然后把结果保存到/tmp/core.log 文件中：&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;find . -type f -print&lt;/td&gt;
      &lt;td&gt;xargs grep “hostname” 用grep命令在所有的普通文件中搜索hostname这个词&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;find ./ -mtime +3 -print&lt;/td&gt;
      &lt;td&gt;xargs rm -f –r 删除3天以前的所有东西 （find . -ctime +3 -exec rm -rf {} \;）&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;find ./ -size 0&lt;/td&gt;
      &lt;td&gt;xargs rm -f &amp;amp; 删除文件大小为零的文件&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;find命令配合使用exec和xargs可以使用户对所匹配到的文件执行几乎所有的命令。&lt;/p&gt;

&lt;p&gt;2、grep命令&lt;/p&gt;

&lt;p&gt;grep (global search regular expression(RE) and print out the line,全面搜索正则表达式并把行打印出来)是一种强大的文本搜索工具，它能使用正则表达式搜索文本，并把匹配的行打印出来。&lt;/p&gt;

&lt;p&gt;2.1、grep命令的一般选项及实例
grep [OPTIONS] PATTERN [FILE…] 
grep [OPTIONS] [-e PATTERN | -f FILE] [FILE…]&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;grep命令用于搜索由Pattern参数指定的模式，并将每个匹配的行写入标准输出中。这些模式是具有限定的正则表达式，它们使用ed或egrep命令样式。如果在File参数中指定了多个名称，grep命令将显示包含匹配行的文件的名称。对 shell 有特殊含义的字符 ($, *, [,&lt;/td&gt;
      &lt;td&gt;, ^, (, ), \ ) 出现在 Pattern参数中时必须带双引号。如果 Pattern参数不是简单字符串，通常必须用单引号将整个模式括起来。在诸如 [a-z], 之类的表达式中，-（减号）cml 可根据当前正在整理的序列来指定一个范围。整理序列可以定义等价的类以供在字符范围中使用。如果未指定任何文件，grep会假定为标准输入。&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;2.2、grep正则表达式元字符集(基本集)
^  锚定行的开始 如：’^grep’匹配所有以grep开头的行。&lt;/p&gt;

&lt;p&gt;$  锚定行的结束 如：’grep$’匹配所有以grep结尾的行。&lt;/p&gt;

&lt;p&gt;.   匹配一个非换行符的字符 如：’gr.p’匹配gr后接一个任意字符，然后是p。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;匹配零个或多个先前字符 如：’ &lt;em&gt;grep’匹配所有一个或多个空格后紧跟grep的行。 .&lt;/em&gt;一起用代表任意字符。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;[] 匹配一个指定范围内的字符，如’[Gg]rep’匹配Grep和grep。&lt;/p&gt;

&lt;p&gt;[^]  匹配一个不在指定范围内的字符，如：’[^A-FH-Z]rep’匹配不包含A-F和H-Z的一个字母开头，紧跟rep的行。&lt;/p&gt;

&lt;p&gt;(..)  标记匹配字符，如：’(love)‘，love被标记为1。&lt;/p&gt;

&lt;p&gt;&amp;lt;  锚定单词的开始，如：’&amp;lt;grep’匹配包含以grep开头的单词的行。&lt;/p&gt;

&lt;p&gt;&amp;gt;  锚定单词的结束，如’grep&amp;gt;‘匹配包含以grep结尾的单词的行。&lt;/p&gt;

&lt;p&gt;x{m} 连续重复字符x，m次，如：’o{5}‘匹配包含连续5个o的行。&lt;/p&gt;

&lt;p&gt;x{m,} 连续重复字符x,至少m次，如：’o{5,}‘匹配至少连续有5个o的行。&lt;/p&gt;

&lt;p&gt;x{m,n} 连续重复字符x，至少m次，不多于n次，如：’o{5,10}‘匹配连续5–10个o的行。&lt;/p&gt;

&lt;p&gt;\w  匹配一个文字和数字字符，也就是[A-Za-z0-9]，如：’G\w*p’匹配以G后跟零个或多个文字或数字字符，然后是p。&lt;/p&gt;

&lt;p&gt;\W  w的反置形式，匹配一个非单词字符，如点号句号等。\W*则可匹配多个。&lt;/p&gt;

&lt;p&gt;\b  单词锁定符，如: ‘\bgrep\b’只匹配grep，即只能是grep这个单词，两边均为空格。&lt;/p&gt;

&lt;p&gt;2.3、grep命令的常用选项及实例
-?&lt;/p&gt;

&lt;p&gt;同时显示匹配行上下的？行，如：grep -2 pattern filename同时显示匹配行的上下2行。&lt;/p&gt;

&lt;p&gt;-b，–byte-offset&lt;/p&gt;

&lt;p&gt;打印匹配行前面打印该行所在的块号码。&lt;/p&gt;

&lt;p&gt;-c,–count&lt;/p&gt;

&lt;p&gt;只打印匹配的行数，不显示匹配的内容。&lt;/p&gt;

&lt;p&gt;-f File，–file=File&lt;/p&gt;

&lt;p&gt;从文件中提取模板。空文件中包含0个模板，所以什么都不匹配。&lt;/p&gt;

&lt;p&gt;-h，–no-filename&lt;/p&gt;

&lt;p&gt;当搜索多个文件时，不显示匹配文件名前缀。&lt;/p&gt;

&lt;p&gt;-i，–ignore-case&lt;/p&gt;

&lt;p&gt;忽略大小写差别。&lt;/p&gt;

&lt;p&gt;-q，–quiet&lt;/p&gt;

&lt;p&gt;取消显示，只返回退出状态。0则表示找到了匹配的行。&lt;/p&gt;

&lt;p&gt;-l，–files-with-matches&lt;/p&gt;

&lt;p&gt;打印匹配模板的文件清单。&lt;/p&gt;

&lt;p&gt;-L，–files-without-match&lt;/p&gt;

&lt;p&gt;打印不匹配模板的文件清单。&lt;/p&gt;

&lt;p&gt;-n，–line-number&lt;/p&gt;

&lt;p&gt;在匹配的行前面打印行号。&lt;/p&gt;

&lt;p&gt;-s，–silent&lt;/p&gt;

&lt;p&gt;不显示关于不存在或者无法读取文件的错误信息。&lt;/p&gt;

&lt;p&gt;-v，–revert-match&lt;/p&gt;

&lt;p&gt;反检索，只显示不匹配的行。&lt;/p&gt;

&lt;p&gt;-w，–word-regexp&lt;/p&gt;

&lt;p&gt;如果被&amp;lt;和&amp;gt;引用，就把表达式做为一个单词搜索。&lt;/p&gt;

&lt;p&gt;-V，–version&lt;/p&gt;

&lt;p&gt;显示软件版本信息。&lt;/p&gt;

&lt;p&gt;=====&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;ls -l&lt;/td&gt;
      &lt;td&gt;grep ‘^a’ 通过管道过滤ls -l输出的内容，只显示以a开头的行。&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;grep ‘test’ d* 显示所有以d开头的文件中包含test的行。&lt;/p&gt;

&lt;p&gt;grep ‘test’ aa bb cc 显示在aa，bb，cc文件中匹配test的行。&lt;/p&gt;

&lt;p&gt;grep ‘[a-z]’ aa 显示所有包含每个字符串至少有5个连续小写字符的字符串的行。&lt;/p&gt;

&lt;p&gt;grep ‘w(es)t.&lt;em&gt;’ aa 如果west被匹配，则es就被存储到内存中，并标记为1，然后搜索任意个字符(.&lt;/em&gt;)，这些字符后面紧跟着另外一个es()，找到就显示该行。如果用egrep或grep -E，就不用”“号进行转义，直接写成’w(es)t.*‘就可以了。&lt;/p&gt;

&lt;p&gt;grep -i pattern files ：不区分大小写地搜索。默认情况区分大小写&lt;/p&gt;

&lt;p&gt;grep -l pattern files ：只列出匹配的文件名，&lt;/p&gt;

&lt;p&gt;grep -L pattern files ：列出不匹配的文件名，&lt;/p&gt;

&lt;p&gt;grep -w pattern files ：只匹配整个单词，而不是字符串的一部分(如匹配‘magic’，而不是‘magical’)，&lt;/p&gt;

&lt;p&gt;grep -C number pattern files ：匹配的上下文分别显示[number]行，&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;grep pattern1&lt;/td&gt;
      &lt;td&gt;pattern2 files ：显示匹配 pattern1 或 pattern2 的行，&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;grep pattern1 files&lt;/td&gt;
      &lt;td&gt;grep pattern2 ：显示既匹配 pattern1 又匹配 pattern2 的行。&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;参考文献：&lt;/p&gt;

&lt;p&gt;关于Linux Grep命令使用的详细介绍，http://fanqiang.chinaunix.net/system/linux/2007-03-15/5110.shtml
Linux文件查找命令find,xargs详述，http://www.linuxsir.org/main/?q=node/137#1.1
man文档（man find、man grep）&lt;/p&gt;
</description>
        <pubDate>Sat, 21 May 2016 00:00:00 +0800</pubDate>
        <link>http://shenmimoon.github.io/2016/05/21/Find&Grep.html</link>
        <guid isPermaLink="true">http://shenmimoon.github.io/2016/05/21/Find&Grep.html</guid>
        
        <category>shell</category>
        
        <category>find</category>
        
        <category>grep</category>
        
        <category>linux</category>
        
        
      </item>
    
  </channel>
</rss>
